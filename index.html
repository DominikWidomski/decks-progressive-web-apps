<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Progressive Web Apps</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="/libs/reveal.js/css/reveal.css">
		<link rel="stylesheet" href="/libs/reveal.js/css/theme/night.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="/libs/reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'libs/reveal.js/css/print/pdf.css' : 'libs/reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );

			function changeTheme(name) {
				document.getElementById('theme').setAttribute('href','/libs/reveal.js/css/theme/'+name+'.css'); return false;
			}

			window.addEventListener('change-style-one', function() {
				changeTheme('night');
			})
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->

		<style>
			* {
				box-sizing: border-box;
			}

			ul {
				width: 100%;
			}

			.reveal .list-reset {
				list-style-type: none;
				margin-left: 0;
			}

			.reveal h1 {
				font-size: 2.3em;
			}
		</style>
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<h1>Progressive Web Apps</h1>
					<h3>22&middot;6&middot;16</h3>
					<p>
						<small>Dom @ DD</small>
					</p>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>What makes an app?</h1>
					</section>

					<section>
						<h1>Appiness!</h1>

						<ul>
							<li>Responsive</li>
							<li>Offline
								<ul>
									<li>Persistant</li>
									<li>Network Resiliant</li>
									<li>... Manages sync, user doesn't have to wait for network (relates to prev. pt.)</li>
								</ul>
							</li>
							<li>Render what you have, most achievable content, progressively enhance content</li>
							<li>Notifications, integration with mobile</li>
							<li>Appy Behaviour</li>
							<li>Animated, Juicy, Responsive (Material)</li>
						</ul>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>What are PWAs?</h1>

						<p>
							<blockquote cite="https://developers.google.com/web/progressive-web-apps/">
								<p>
									Progressive Web Applications take advantage of new technologies
									to bring the best of mobile sites and native applications to users.
									They're reliable, fast, and engaging.
								</p>
								<footer>- Google</footer>
							</blockquote>
						</p>

						<aside class="notes">
							So, as you can see, PWAs are not a single specific thing.
							It's an overarching concept like, functional programming,
							<i>...something...</i>
							or web applications themselves.
						</aside>
					</section>

					<section>
						<h1>What makes up PWA</h1>

						<ul>
							<li class="fragment">Instant Loading</li> <!-- Performance -->
							<li class="fragment">Add to Homescreen</li> <!-- Integration -->
							<li class="fragment">Push Notifications</li> <!-- Integration -->
							<li class="fragment">Fast</li> <!-- Performance -->
							<li class="fragment">Secure</li>
							<li class="fragment">Responsive</li>
						</ul>
					</section>

					<section>
						<h1>In a nut shell</h1>

						<div class="fragment">Performance</div>
						<div class="fragment">Integration</div>
						<div class="fragment">Resiliance</div>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>Service Workers!</h1>
					</section>

					<section>
						<h1>Lie-Fi</h1>
					</section>

					<section>
						<i>image of where service worker sits should be here but meh</i>
					</section>

					<section>
						<h1>Adding SW</h1>

						<pre class="hljs lang-javascript"><code>navigator.serviceWorker.register('/worker.js',{
     scope: '/'
 }).then(registerSuccess, registerFailure);</code></pre>

						<aside class="notes">
							<p>
								Remember, the of the provided scope ('/') is not under the max scope allowed ('/js/').
								Adjust the scope, move the SW script, or use Servive-Worker-Allowed HTTP header to allow the scope.
							</p>
						</aside>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>SW Life Cycle</h1>
					</section>

					<section>
						<ol>
							<li>
								<b>Fetch</b> and register SW via <code>serviceWorkerContainer.register()</code>
							</li>
							<li class="fragment">
								If successful, the service worker is executed in a <code>ServiceWorkerGlobalScope</code>.
							</li>
							<li class="fragment">
								The SW is now <b>ready!</b>
							</li>
							<li class="fragment">
								Installation of the worker is attempted when service worker-controlled pages are accessed subsequently.
							</li>
							<li class="fragment">
								When the <code>oninstall</code> handler completes, the service worker is considered <b>installed</b>.
							</li>
							<li class="fragment">
								<b>Activation</b>
							</li>
							<li class="fragment">
								The Service Worker will now <b>control</b> pages.

								<code>navigator.serviceWorker.controller</code>

								<aside class="notes">
									<p>
										1. This is basically a special kind of worker context, running off the main script execution thread, with no DOM access.
									</p>

									<p>
										2. ... to process events
									</p>

									<p>
										3. An Install event is always the first one sent to a service worker (this can be used to start the process of populating an IndexedDB, and caching site assets).
									</p>

									<p>
										This is really the same kind of procedure as installing a native or Firefox OS app — making everything available for use offline.
									</p>

									<p>
										What is `install` fails? What if not all promisses resolve, things aren't cached? Or will they still resolve to failed and install will eventually complete?

										<q>
											"If the promise is rejected, the install fails, and the worker won’t do anything. This is ok, as you can fix your code and then try again the next time registration occurs."
										</q>

										<p>
											If it fails, SW becomes redundant and will be garbage collected.
										</p>
									</p>

									<p>
										4. `event.waitUntil()` allows us to extend the installation stage until certain number of promises resolve.
									</p>

									<p>
										5. When the service worker is installed, it then receives an `activate` event. The primary use of `onactivate` is for cleanup of resources used in previous versions of a Service Worker script, like removing olde caches.

										Also, migrate old data left over from previous versions of SW.

										HOW TO DO THAT?!?!!??!? How do you find the previous version of the worker???
										There's this `navigator.serviceWorker.getRegistration(s?)()`

										Activating stage can also be extended with `event.waitUntil()`

										`self.clients.claim()` or `self.skipWaiting()` or `event.replace()` can be used to start controling all open clients without reloading them.
										Remember this can cause issues with asset versions.
									</p>

									<p>
										The exception is if the worker calls `event.replace()` in the install event, then it takes control of all in-scope pages immediately.
									</p>

									<p>
										6. ...but only those opened after the `register()` is successful. i.e. a document starts life with or without a Service Worker and maintains that for its lifetime. So documents will have to be reloaded to actually be controlled.

										`navigator.serviceWorker.controller` points to the SW controlling the page. `null` otherwise.
									</p>
								</aside>
							</li>
						</ol>
					</section>

					<section>
						<h1>Global Scope</h1>

						<p>
							Each page in scope is operated on by the same SW.
						</p>

						<p>
							Watch global scope and variables!

							<aside class="notes">
								However, SWs are shut down when not in use so don't count on it to persist either.
							</aside>
						</p>
					</section>

					<section>
						<h1>Updating</h1>

						<p>
							SW is considered updated if it's byte different.
						</p>

						<p class="fragment">
							Newly installed SW is not activated till there are no more active pages controlled by the old SW.
						</p>

						<p class="fragment">
							<code>self.clients.claim()</code> or <code>self.skipWaiting()</code> mentioned earlier can bypass that.
						</p>

						<aside class="notes">
							Browser checks for updates in the SW script in the background. If it's byte different it's installed.
						</aside>
					</section>

					<section>
						<h1>Cache and storage</h1>

						<p>
							In <code>activate</code> event, we can do anything that would have broken old SW when it was still in power, anything local that's leftover from previous versions.
						</p>

						<p>
							e.g. Clearing old cache, migrating data.
						</p>

						<aside class="notes">
							Also keep in mind that browsers allocate a finite amount of storage per origin.
							Browser will do its best to keep data for origin but may delete it.
							SW is a lower level API, with great power comes great responsibility.
							We gotta clean up after ourselves.
						</aside>
					</section>

					<section>
						<h1>Events</h1>

						<h2>// life cycle</h2>
						<p>
							install &middot; activate &middot; message
						</p>

						<h2>// actions</h2>
						<p>
							fetch &middot; sync &middot; push
						</p>

						<aside class="notes">
							<h1>
								Make it aparent that SW is just a different context that receives all these events and because of its context it has access to all those APIs
							</h1>

							<p>
								(can we send custom events to SW???)
							</p>
						</aside>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>Fetch!</h1>

						<p><i>New request API</i></p>
					</section>

					<section>
						<p>
							Previously achieved with <code>XMLHttpRequest</code>
						</p>

						<p>
							A more straight-forward promise based way of making network requests.
						</p>
					</section>

					<!-- <section>
						<h1>Before</h1>

						<pre class="hljs lang-javascript"><code>var xhr = new XMLHttpRequest();
xhr.open('GET', path);
xhr.responseType = 'json';

xhr.onload = function() {
  console.log(xhr.response);
};

xhr.onerror = function() {
  console.log("Booo");
};

xhr.send();
</code></pre>
					</section> -->

					<section>
						<code>
							fetch(path).then(response => {});
						</code>

						<aside class="notes">
							<code>fetch(path)</code> takes a path to a resource and returns a <code>Promise</code> resolving to contiain `Response` object.

							This is a HTTP response. You're then responsible to do what you want with it.
						</aside>
					</section>

					<section>
						<h2><code>Request</code> and <code>Response</code></h2>

						<p>
							New constructors related to fetch
						</p>

						<p>
							<code>new Request(url);</code>
						</p>

						<p>
							<code>new Response(body, options)</code>
						</p>
					</section>

					<section>
						<h1>Response</h1>

						<table>
							<tbody>
								<tr>
									<td style="vertical-align: top;">
										<code>
											<ul class="list-reset">
												<li class="fragment">Response.clone()</li>
												<li class="fragment">Response.error()</li>
												<li class="fragment">Response.redirect()</li>
											</ul>
										</code>
									</td>

									<td style="vertical-align: top;">
										<code>
											<ul class="list-reset">
												<li class="fragment">Body.arrayBuffer()</li>
												<li class="fragment">Body.blob()</li>
												<li class="fragment">Body.formData()</li>
												<li class="fragment">Body.json()</li>
												<li class="fragment">Body.text()</li>
											</ul>
										</code>
									</td>
								</tr>
							</tbody>
						</table>
					</section>


					<section>
						<h1>Cloning</h1>

						<p>Response can only be read once</p>

						<aside class="notes">
							Simple 'read' methods on response use stream reader, they drain/consume the response.
							Response needs to be cloned to be used again, also for caching.
						</aside>
					</section>


					<section>
						<h2>CORS and opaque</h2>

						<p>
							<code>
								fetch(externalUrl, { mode: 'no-cors' })
							</code>
						</p>

						<p>
							<code>
								response.type === 'opaque'
							</code>
						</p>

						<aside class="notes">
							<b>Cross Site Resource Sharing</b>
							To make a request from

							This is similar to the request an &lt;img&gt; makes.
							You can't read the content of the response as it could contain private information, but it can be consumed by other APIs.

							Can be cached or returned to the original fetch request, etc.

							Response is severely restricted:

							<ul>
								<li>body is null</li>
								<li>ok is false</li>
								<li>status is 0</li>
							</ul>

							other statuses include:

							basic: normal, same origin response
							cors: response from a valid cross-origin request
							error: network error. status is 0, headers are empty and immutable. This is obtained from Response.error()
							opaque: response for “no-cors” request to cross-origin resource

							(https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/)
						</aside>
					</section>

					<section>
						<h1>Abort</h1>

						<p><i>nope!</i></p>

						<aside class="notes">
							Fetch does not currently support aborting/canceling requests, which XHR does.
						</aside>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>Cache!</h1>

						<p><i>async origin request/response storage</i></p>
					</section>

					<section>
						<h1>Old</h1>

						AppCache - Confusing, unclear, obfuscated manifest based API, magical black box
					</section>

					<section>
						<h1>New</h1>

						<p>
							A store of <code>Response</code>es keyed against <code>Request</code>s.
						</p>

						<aside class="notes">
							We manually save and delete from it, storing responses to any request and retrieving requests.
						</aside>
					</section>

					<section>
						<h1>How to</h1>

						<pre class="hljs lang-javascript"><code>caches.open(CURRENT_VERSION_CACHE_KEY).then(cache => {
	return cache.addAll([
		'/js/app.js'
		'/css/app.css',
		'/images/icon.png',
		'/images/loader.svg',
		'/views/loader.html',
		'/views/offline.html',
 	]);
});</code></pre>
					</section>

					<section>
						<h1>How to</h1>

						<pre class="hljs lang-javascript"><code>this.addEventListener('fetch', event => {
	// cached
	event.respondWith(caches.match(event.request));

	// not cached
	event.respondWith(fetch(event.request));
});

</code></pre>
					</section>

					<!-- <section>
						<h1>How to refresh assets in cache programatically?</h1>
					</section> -->

					<!-- <section>
						<h1>Caching and versioning assets</h1>

						<p>
							app.css?v=1.0.0 =&gt; app.css?v=1.1.0 <br />
							<small>or</small> <br />
							app-v1.css =&gt; app-v2.css
						</p>

						<p>
							Can also use hash of the content. Which cleaverly means that if content does not change the cache is not broken.
						</p>

						<p>
							Consider breaking cache all the time when in local dev. Can use time stamp for <code>?v</code>
						</p>

						<p>
							Refreshing - client revalidates with server on refresh.
						</p>

						<aside class="notes">
							Client has 1.0.0 cached, it then receives 1.1.0, server doesn't need to have 1.0.0 because it hopefully no longer uses it and Client will get rid of it when it does no longer need it.
						</aside>
					</section> -->
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>Push!</h1>

						<p><i>Push messaging, send message from server to client</i></p>
					</section>

					<section>
						<p>
							Re-engage with your audience by showing, relevant, timely,
							and contextual notifications.
						</p>

						<aside class="notes">
							 ... when the browser is closed
						</aside>
					</section>

					<section>
						<h1>Google Cloud Platform</h1>

						<p>
							Register for GCP to setup Google Cloud Messaging and be able to push messages directly to Chrome!
						</p>
					</section>

					<section>
						Registering, expiring, refreshing, multiple devices
					</section>

					<section>
						<code>
							https://android.googleapis.com/gcm/send/<b>dxcNlXkngUc:APA91bHtGp8RzObJweu1wcyBVP5bqa8qzLoms5rJ_iO09u22zTkIEhhQ68SN4iFm8JtPzyJkn2AE1CL_JT_QmcPtiDzZielDYLzG_jwRAp6zwRHnoTA5cHtqrFNR-YPXUnwXeywaK8LG</b>
						</code>
					</section>

					<section>
						<h1>Send notification / PUSH MESSAGE</h1>

						<pre>
							<!-- http://highlightjs.readthedocs.io/en/latest/css-classes-reference.html#language-names-and-aliases -->
							<code class="hljs lang-bash" data-trim contenteditable>
curl
--header "Authorization: key=&lt;PUSH_API_KEY&gt;"
--header "Content-Type: application/json"
https://android.googleapis.com/gcm/send -d
	"{\"registration_ids\":[
		\"&lt;USER_REGISTRATION_ID&gt;\"
	]}"
							</code>
						</pre>
					</section>

					<section>
						https://developers.google.com/web/updates/2015/03/push-notifications-on-the-open-web
						https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification
					</section>

					<section>
						<h1>In and Out</h1>
						<h2>... of the SW</h2>

						<h3>WINDOW</h3>
						<pre>
							<code class="hljs lang-javascript">
if (!("Notification" in window)) {
  alert("This browser does not support desktop notification");
}

// Let's check whether notification permissions have already been granted
else if (Notification.permission === "granted") {
  // If it's okay let's create a notification
  var notification = new Notification("Hi there!");
}

// Otherwise, we need to ask the user for permission
else if (Notification.permission !== 'denied') {
  Notification.requestPermission(function (permission) {
    // If the user accepts, let's create a notification
    if (permission === "granted") {
      var notification = new Notification("Hi there!");
    }
  });
}
							</code>
						</pre>

						<h3>SERVICE WORKER</h3>
						<pre>
							<code class="hljs lang-javascript">
navigator.serviceWorker.register('sw.js');

function showNotification() {
  Notification.requestPermission(function(result) {
    if (result === 'granted') {
      navigator.serviceWorker.ready.then(function(registration) {
        registration.showNotification('Vibration Sample', {
          body: 'Buzz! Buzz!',
          icon: '../images/touch/chrome-touch-icon-192x192.png',
          vibrate: [200, 100, 200, 100, 200, 100, 200],
          tag: 'vibration-sample'
        });
      });
    }
  });
}
							</code>
						</pre>

						<aside class="notes">
							https://developer.mozilla.org/en/docs/Web/API/notification
						</aside>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>Sync!</h1>

						<p>Deferring tasks until user has connectivity</p>

						<aside class="notes">
							https://developers.google.com/web/updates/2015/12/background-sync?hl=en
						</aside>
					</section>

					<section>
						<p>
							You can register for sync tasks for when the browser next has internet connectivity.
						</p>

						<p>
							Registering sync when you're online fires the event immediately.
						</p>
					</section>

					<section>
						<h1>Register for sync</h1>

						<pre class="hljs lang-javascript">
							<code>
// Then later, request a one-off sync:
navigator.serviceWorker.ready.then(function(swRegistration) {
  return swRegistration.sync.register('mySyncTag');
});
							</code>
						</pre>
					</section>

					<section>
						<h1>Respond to sync</h1>

						<pre class="hljs lang-javascript">
							<code>
self.addEventListener('sync', function(event) {
  if (event.tag == 'mySyncTag') {
    event.waitUntil(doSomeStuff());
  }
});
							</code>
						</pre>
					</section>

					<section>
						<h1>ExtendableEvent.waitUntil()</h1>

						<p>
							Method extends the lifetime of the event.
						</p>

						<p>
							Associated with `instal` and `activate` SW events.
						</p>

						<p>
							Extends installing, activation or any stage until promise is resolved.
						</p>

						<p>
							Blocks other events.
						</p>
					</section>

					<section>
						<h1>Tags</h1>

						<p>
							Sync are registered with a tag ('mySyncTag').
							Registering to the same tag will coalesce the with existing sync.
							Which means it will only fire <b>ONCE</b>.
						</p>
					</section>

					<section>
						<h1>Failure</h1>

						<p>
							If it fails, another sync will be scheduled to retry.
						</p>

						<aside class="notes">
							Retry syncs also wait for connectivity, and employ an exponential back-off.
						</aside>
					</section>

					<section>
						<h1>Restrictions</h1>

						<aside class="notes">
							(Not sure how accurate those are, read in an article from 12/2015)
						</aside>

						<p class="fragment">
							Can only be registered when user is on the page.
						</p>

						<p class="fragment">
							The event execution time is capped.

							<aside class="notes">
								... cannot ping server continuously or execute long running tasks.
							</aside>
						</p>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section data-background="#A53F2B">
					<section>
						<h1>Homescreen!</h1>
					</section>

					<section>
						<ul>
							<li class="fragment">Icon on homescreen</li>
							<li class="fragment">Splash Screen</li>
							<li class="fragment">Integrated with device</li>
							<li class="fragment">Manifest file in JSON</li>
						</ul>

						<aside class="notes">
							<p>
								Manifest much like Android / Java development
							</p>
						</aside>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>Manifest</h1>

						<code>
							...
							snippets of code from the manifest that are relevant to the homescreen
							...
							icons!
							...
							splash screen
							...
							how it presents itself? standalone etc?
							...
						</code>

						<aside class="notes">
							<p>
								First level citizen in the apps carousel if you choose so, which is specified by... (manifest)
							</p>
						</aside>
					</section>

					<section>
						<h1>theme-color</h1>

						<code>&lt;meta name=&quot;theme-color&quot; content=&quot;#e92c6c&quot;&gt;</code>

						<aside class="notes">
							https://developers.google.com/web/updates/2014/11/Support-for-theme-color-in-Chrome-39-for-Android?hl=en
						</aside>
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<section>
						<h1>When?</h1>
					</section>

					<section>
						https://jakearchibald.github.io/isserviceworkerready/
					</section>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<h1>Quick recap</h1>

					<ul>
						<li class="fragment">Online network handling</li>
						<li class="fragment">Offline network handling</li>
						<li class="fragment">Fetch</li>
						<li class="fragment">Cache</li>
						<li class="fragment">Background Sync</li>
						<li class="fragment">Push</li>
						<li class="fragment">Extensible web manifest</li>
						<li class="fragment">Device integration</li>
					</ul>
				</section>


				<section>
					<h1>All this is WIP!!!</h1>

					<aside class="notes">
						Many of these features are not fully implemented yet or even their specs are not fully defined yet.
						Expect much more awesomeness from these as well as all other modern web APIs.
					</aside>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


				<section>
					<h1><em>Fin.</em></h1>

					<p>Questions?</p>
				</section>


				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->
				<!-- ******************************************************************************************************* -->


			</div>

		</div>

		<script src="/libs/reveal.js/lib/js/head.min.js"></script>
		<script src="/libs/reveal.js/js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: '/libs/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '/libs/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '/libs/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '/libs/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '/libs/reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: '/libs/reveal.js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
